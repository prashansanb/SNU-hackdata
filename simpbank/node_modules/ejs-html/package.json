{
  "_from": "ejs-html",
  "_id": "ejs-html@5.1.5",
  "_inBundle": false,
  "_integrity": "sha512-GYZBR1v1NKlXDt7z3Iwk84XUNxCnNdUFLXA3tYdTWnTwIJ1ogC1tdC0fRaNHQzifwTudSDLdsjqvmNfGoqGxPQ==",
  "_location": "/ejs-html",
  "_phantomChildren": {},
  "_requested": {
    "escapedName": "ejs-html",
    "fetchSpec": "latest",
    "name": "ejs-html",
    "raw": "ejs-html",
    "rawSpec": "",
    "registry": true,
    "saveSpec": null,
    "type": "tag"
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/ejs-html/-/ejs-html-5.1.5.tgz",
  "_shasum": "bfc94906db70dcd40b455fa13adda2ef3ec28553",
  "_spec": "ejs-html",
  "_where": "D:\\WebD2\\Block project",
  "author": {
    "email": "sitegui@sitegui.com.br",
    "name": "Sitegui"
  },
  "bugs": {
    "url": "https://github.com/sitegui/ejs-html/issues"
  },
  "bundleDependencies": false,
  "dependencies": {
    "source-map": "^0.7.0"
  },
  "deprecated": false,
  "description": "Embedded JavaScript HTML templates. An implementation of EJS focused on run-time performance, HTML syntax checking, minified HTML output and custom HTML elements.",
  "devDependencies": {
    "mocha": "^5.0.0",
    "should": "^13.2.1"
  },
  "engines": {
    "node": ">=6"
  },
  "homepage": "https://github.com/sitegui/ejs-html#readme",
  "keywords": [
    "custom elements",
    "ejs",
    "engine",
    "html",
    "minification",
    "template",
    "web components"
  ],
  "license": "MIT",
  "main": "./index.js",
  "name": "ejs-html",
  "optionalDependencies": {},
  "readme": "# EJS HTML\r\n[![Build Status](https://travis-ci.org/sitegui/ejs-html.svg?branch=master)](https://travis-ci.org/sitegui/ejs-html)\r\n[![Inline docs](https://inch-ci.org/github/sitegui/ejs-html.svg?branch=master)](https://inch-ci.org/github/sitegui/ejs-html)\r\n[![Dependency Status](https://david-dm.org/sitegui/ejs-html.svg)](https://david-dm.org/sitegui/ejs-html)\r\n\r\nEmbedded JavaScript HTML templates. An implementation of EJS focused on run-time performance, HTML syntax checking, minified HTML output and custom HTML elements.\r\n\r\n## Usage\r\n`npm install ejs-html --save`\r\n\r\n```js\r\nlet ejs = require('ejs-html')\r\n\r\nlet html = ejs.render('<input type=\"text\" disabled=\"<%=disabled%>\" value=\"<%=value%>\" />', {\r\n    disabled: false,\r\n    value: 'hi you'\r\n}, {\r\n    vars: ['disabled', 'value']\r\n})\r\n\r\n// html = '<input type=text value=\"hi you\">'\r\n```\r\n\r\n## Why another EJS implementation?\r\nThis module is inspired by [EJS](http://ejs.co/), and is a subset of its syntax, focused on giving HTML first-class support. That is, not all EJS are valid EJS-HTML. Most features listed bellow are possible only with an HTML-aware parser.\r\n\r\nCheck their excellent site for EJS-specific docs and tutorials.\r\n\r\nStrictly speaking, this *is not* even EJS (details bellow).\r\n\r\n## Breaking changes in v5\r\nOld versions compiled to sloppy mode and used the `with(locals)` block by default.\r\nThat allowed one to write `<%= a %>` instead of `<%= locals.a %>` but had more unwanted consequences.\r\nRead more about what changed and how to opt-out from the change in [HISTORY.md](https://github.com/sitegui/ejs-html/blob/master/HISTORY.md).\r\n\r\n## Features\r\n\r\n### Compile-time HTML minification\r\nThe template source is parsed and minified on compile time, so there is no impact on render-time. The minification applies these rules:\r\n\r\n* Collapse text whitespace: `<b>Hello\\n\\t you</b>` is transformed to `<b>Hello\\nyou</b>`\r\n* Remove attribute quotes: `<div class=\"alert\">` → `<div class=alert>`\r\n* Normalize attributes spaces: `<input \\n required>` → `<input required>`\r\n* Normalize class spaces: `<div class=\"  a   b \">` → `<div class=\"a b\">`\r\n* Simplify boolean attributes: `<input required=\"oh-yeah!\">` → `<input required>`\r\n* Remove self-close slash: `<br />` → `<br>`\r\n\r\n### Render-time error mapping\r\nErrors during render-time are mapped back to their original source location (that is, we keep an internal source map)\r\n\r\n```js\r\nejs.render(`<select>\r\n<% for (let option of locals.options) { %>\r\n    <option value=\"<%= option.value %>\">\r\n      <%= option.text %>\r\n    </option>\r\n<% } %>\r\n</select>`, {\r\n    options: [null]\r\n})\r\n```\r\n\r\n```\r\nTypeError: ejs:3\r\n 1    | <select>\r\n 2    | <% for (let option of options) { %>\r\n 3 >> |         <option value=\"<%= option.value %>\">\r\n 4    |                 <%= option.text %>\r\n 5    |         </option>\r\n\r\nCannot read property 'value' of null\r\n    at eval (eval at module.exports (D:\\Programs\\ejs-html\\lib\\compile.js:45:20), <anonymous>:4:51)\r\n    at D:\\Programs\\ejs-html\\lib\\compile.js:64:11\r\n    at Object.module.exports.render (D:\\Programs\\ejs-html\\index.js:12:48)\r\n```\r\n\r\n### Boolean attributes\r\nAttributes like `disabled` and `checked` are recognized as boolean. So one may write `disabled=<%=disabled%>` instead of `<%if(disabled){%>disabled<%}%>`, as one must in plain EJS.\r\n\r\nThis is one point that makes EJS-HTML not EJS-compliant. In EJS, any literal text is outputed as is. In the example above this is not what happens: the text `disabled=` is not outputed if the local value `disabled` is falsy, since ejs-html knows this is a boolean attribute.\r\n\r\n### Server-side compiled, client-side rendered\r\nCompile the template server-side and export a function to render it in the client-side.\r\n\r\n### Extensible semantics\r\nTransformers may be registered to change the parsed elements tree and implement custom semantics.\r\n\r\nFor example:\r\n```js\r\n// change I elements for EM\r\n\r\nvar render = ejs.compile('<i>Hi</i> <p><i>Deep</i></p>', {\r\n    transformer: function translate(tokens) {\r\n        tokens.forEach(token => {\r\n            if (token.type === 'element') {\r\n                if (token.name === 'i') {\r\n                    token.name = 'em'\r\n                }\r\n                translate(token.children)\r\n            }\r\n        })\r\n    }\r\n})\r\n\r\nrender() // '<em>Hi</em> <p><em>Deep</em></p>'\r\n```\r\n\r\n### Custom elements\r\nUnleash the semantic power of HTML with custom elements. To use custom elements you must first define one:\r\n\r\nFor example, define your own confirm dialog (in `dialog.ejs`):\r\n```html\r\n<div class=\"dialog\">\r\n    <div class=\"dialog-title\">\r\n        <%= title %>\r\n        <% if (closable) { %>\r\n            <div class=\"dialog-close\">X</div>\r\n        <% } %>\r\n    </div>\r\n    <eh-placeholder>\r\n        <!-- dialog content goes here -->\r\n    </eh-placeholder>\r\n    <div class=\"dialog-buttons\">\r\n        <button class=\"dialog-yes\">Yes</button>\r\n        <button class=\"dialog-no\">No</button>\r\n    </div>\r\n</div>\r\n```\r\n\r\nAnd then use it, like:\r\n```html\r\n<custom-dialog title=\"Wanna Know?\" closable>\r\n    <em>HTML</em> Content\r\n</custom-dialog>\r\n```\r\n\r\nThe attributes on the `custom-dialog` tag is passed as locals to `dialog.ejs` and its content replaces the `<eh-placeholder></eh-placeholder>` tag.\r\n\r\nCustom elements is a more powerful replacement for ejs' include feature.\r\n\r\nThis is the most basic usage of this feature. For more (like passing JS values and multiple content areas), see [custom-els.md](https://github.com/sitegui/ejs-html/blob/master/custom-els.md)\r\n\r\n## Source maps\r\nCompile with support for source map generation (requires node >= v8, since `source-map` has dropped support for older versions)\r\n```js\r\nlet fn = ejs.compile('Hello <%= locals.world %>', {sourceMap: true})\r\n// The actual result may vary\r\nfn.code // \"use strict\";locals=locals||{};let __c=locals.__contents||{};return \"Hello \"+(__l.s=__l.e=1,__e(locals.world));\r\nfn.map // {\"version\":3,\"sources\":[\"ejs\"],\"names\":[],\"mappings\":\"gGAAU,Y\",\"file\":\"ejs.js\"}\r\nfn.mapWithCode // {\"version\":3,\"sources\":[\"ejs\"],\"names\":[],\"mappings\":\"gGAAU,Y\",\"file\":\"ejs.js\",\"sourcesContent\":[\"Hello <%= locals.world %>\"]}\r\n```\r\n\r\n## Missing features\r\nThe following list of features are supported in other EJS implementations, but not by this one (at least, yet):\r\n\r\n* No support for custom delimiters\r\n* No caching\r\n* No built-in express support\r\n* No include: use custom elements instead\r\n\r\n## API\r\n\r\nThe main API is the `compile` function. Everything else is auxiliary.\r\n\r\n### compile(source[, options])\r\nCompile the given EJS-HTML source into a render function. `options` is an optional object, with the following optional keys:\r\n\r\n* `compileDebug`: if `false`, no extended context will be added to exceptions thrown at runtime (defaults to `true`). If `true`, the compiled code will be larger and will include the original EJS source\r\n* `filename`: used to name the file in render-time error's stack trace\r\n* `transformer`: a function that can transform the parsed HTML element tree, before the minification and compilation. This should return a new array of tokens or `undefined` to use the same (in case of in-place changes). Consult the definition of a `Token` in the [parse.js](https://github.com/sitegui/ejs-html/blob/master/lib/parse.js) file.\r\n* `strictMode`: if `false`, use sloppy mode and wrap the code in a `with(locals) {}` block (defaults to `true`).\r\n* `vars`: an array of var names that will be exposed from `locals` (defaults to `[]`).\r\n* `sourceMap`: if `true`, create and return the source map\r\n\r\nThis will return a compiled render function that can then be called like: `render(locals[, renderCustom])`. `locals` is the data object used to fill the template. `renderCustom` is an optional function used to render custom elements, see [custom-els.md](https://github.com/sitegui/ejs-html/blob/master/custom-els.md) for more info about it.\r\n\r\nThe returned function has three extra properties if `sourceMap` is active:\r\n* `fn.code`: compiled JS code\r\n* `fn.map`: source map without the source code\r\n* `fn.mapWithCode`: source map with the source code\r\n\r\n### compile.standAlone(source[, options])\r\nLike `compile()`, but returns the function body code as a string, so that it can be exported somewhere else. A use case for this is compile the EJS template in the server, export the function to the client and render in the browser:\r\n\r\n```js\r\n// On the server\r\nlet functionBody = ejs.compile.standAlone('<p>Hi <%=name%></p>', {vars: ['name']})\r\n\r\n// On the client\r\nvar render = new Function('locals, renderCustom', functionBody)\r\nrender({name: 'you'}) // <p>Hi you</p>\r\n```\r\n\r\n### compile.standAloneAsObject(source[, options])\r\nLike `compile.standAlone()`, but returns an object with three properties:\r\n* `obj.code`: the compiled code, the same value returned by `compile.standAlone()`\r\n* `obj.map` and `obj.mapWithCode`: extra properties when `sourceMap` option is active\r\n\r\n### render(source[, locals[, options]])\r\nJust a convinience for `compile(source, options)(locals)`.\r\n\r\n### parse(source)\r\nParse the given EJS-HTML source into a array of tokens. Use for low-level, crazy thinks (like some internal tooling).\r\n\r\n### reduce(tokens[, options])\r\nRemove comments, transform fixed tokens back to text and apply HTML minification. Use for low-level, crazy things.\r\n\r\n### escape.html(str)\r\nReturn a HTML-safe version of `str`, escaping &, <, >, \" and '\r\n\r\n### escape.js(str)\r\nEscape as to make safe to put inside double quotes: `x = \"...\"`, escaping \\, \\n, \\r and \"\r\n\r\n### escape.getSnippet(source, lineStart, lineEnd)\r\nExtract the code snippet in the given region (used internally to create error messages)",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/sitegui/ejs-html.git"
  },
  "scripts": {
    "test": "mocha test"
  },
  "version": "5.1.5"
}
